#### 平均负载值

每当我们发现系统变慢时，通常做的第一件事，就是执行top或者uptime命令，来了解系统的负载情况。

```bash
> uptime

17:03:44 up 352 days,  6:09,  1 user,  load average: 0.23, 0.20, 0.22
```
上面命令行中打出的分别是,当前时间，系统运行时间以及正在登陆的用户数.

```bash
17:03:44  #系统当前时间
up 352 days #系统运行时间
1 user     #正在登陆的用户数
```

而最后的三个数字呢，依次则是过去1分钟，5分钟，15分钟的平均负载值（Load Average）.

#### 什么是平均负载值？

平均负载值：

平均负载就是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它和CPU使用率并没有直接关系。

平均负载，也就是系统的平均活跃进程数，它反映了系统的整体负载情况，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均复制子。
理想情况下，平均负载等于逻辑 CPU 个数，这表示每个 CPU 都恰好被充分利用。如果平均负载大于逻辑 CPU 个数，就表示负载比较重了。

什么叫可运行状态的进程？

可运行状态的进程：指的是正在使用CPU或者正在等待CPU的进程，也就是我们常用ps命令看到的，处于R状态（Running 或 Runnable）的进程.

```bash
> ps aux | grep dd
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root       1120  102  0.1 106212  1724 pts/1    R+   17:50   0:03 dd if=/dev/zero of=/tmp/test bs=1M count=1000

#参数备注说明：
- [x] USER:该进程属于的用户。
- [x] PID：该进程的进程号。
- [x] %CPU：该进程使用掉的CPU资源百分比。
- [x] %MEM：该进程所占用的物理内存百分比。
- [x] VSZ：该进程使用掉的虚拟内存量（单位Kbytes）
- [x] RSS：该进程占用的固定的内存量（单位Kbytes）
- [x] TTY：该进程是在哪个终端机上面运作的，若与终端机无关，则显示“？”，另外，tty1-tty6是本机上面的登入者进程，若为pts/0等，则表示为由网络连接进主机的进程。
- [x] STAT：该进程目前的状态，主要的状态包括如下几种。
    - R：正在运行，或者是可以运行。
    - S：正在终端睡眠中，可以由某些信号唤醒。
    - D：不可中断睡眠。
    - T：正在侦测或者是停止了。
    - Z：已经终止，但是其父进程无法正常终止它，从而变成zombie（僵尸）进程的状态
    - +：前台进程。
    - l：多线程进程。
    - N：低优先级进程。
    - <：高优先级进程。
    - s：进程领导者。
    - L：已将页面锁定到内存中。
- [x] START：该进程被触发启动的时间
- [x] TIME：该进程实际使用CPU运作的时间
- [x] COMMAND：该进程的实际命令。
```

#### 不可中断状态的进程

不可中断状态的进程,指的是正处于内核态关键流程中的进程，并且这些流程是不可打断的。
例如：等待硬件设备的I/O响应，也就是我们在ps命令中看到的D状态（Uninterruptible Sleep，也叫做Disk Sleep）的进程.

#### 平均活跃进程数

平均活跃进程数：最直观的理解就是单位时间内的活跃进程数，但实际上是活跃进程数的指数衰减平均值。
这个指数衰减平均值的详细含义不用计较，这只是系统的一种更快速的计算方式，你把它直接当成活跃进程数的平均值也没问题。 


#### 平均负载值为多少时合理?
 
平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用CPU的进程，还包括等待CPU和等待I/O的进程。
 
CPU使用率，是单位时间内CPU繁忙情况的统计，跟平均负载并不一定完全对应。比如：

* CPU密集型进程，使用大量CPU会导致平均负载升高，此时两者是一致的。
* I/O密集型进程，等待I/O也会导致平均负载升高，但CPU使用率不一定很高。
* 大量等待CPU的进程调度也会导致平均负载升高，此时的CPU使用率也会比较高。


```bash
#系统环境示例
> cat /etc/redhat-release 
CentOS Linux release 7.6.1810 (Core)
> uname -r
3.10.0-957.21.3.el7.x86_64
> yum -y install epel-release
> yum -y install stress sysstat

#更新sysstat版本
> ls
anaconda-ks.cfg  sysstat-12.1.5-1.x86_64.rpm
> yum -y localinstall sysstat-12.1.5-1.x86_64.rpm
> pidstat -V
sysstat 版本 12.1.5
(C) Sebastien Godard (sysstat <at> orange.fr)
```


stress：Linux系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景

sysstat:包含了常用的Linux性能工具，用来监控和分析系统的性能。

我们的案例会用到这个包的两个命令mpstat和pidstat

* mpstat：一个常用的多核CPU性能分析工具，用来实时查看每个CPU的性能指标，以及所有CPU的平均指标
* pidstat：一个常用的进程性能分析工具，用来实时查看进程的CPU，内存，I/O以及上下文切换等性能指标。

在服务器上运行的服务分为, CPU密集型和IO密集型.

* CPU密集型:

CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读写IO(硬盘/内存)，IO在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。

在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。

CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。

* IO密集型:

IO密集型指的是系统的CPU性能相对硬盘、内存要好很多. 此时，系统运作，大部分的状况是CPU在等IO (硬盘/内存) 的读/写操作，此时CPU Loading并不高。

IO bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量IO操作，而pipeline做得不是很好，没有充分利用处理器能力。

* 内存使用率:

内存使用率指的是此进程所开销的内存。占内存大的程序不一定会占用很多的CPU资源，而占CPU大的程序也不一定开销太大的内存。某一程序的CPU占用率过高会影响其他程序的运行。而某一程序占用内存过大，会影响机器的整体性能。

* CPU使用率

CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等。

用户 CPU 使用率，包括用户态 CPU 使用率(user) 和低优先级用户态 CPU 使用率 (nice)，表示 CPU 在用户态运行的时间百分比。用户 CPU 使用率高，通常说明有应用程序比较繁忙。

系统 CPU 使用率，表示 CPU 在内核态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明内核比较繁忙。

等待 I/O 的 CPU 使用率，通常也称为 iowait，表示等待 I/O 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。

软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。

#### CPU 缓存的命中率

由于CPU 发展的速度远快于内存的发展， CPU 的处理速度就比内存的访问速度快得多。这样，CPU 在访问内存的时候，免不了要等待内存的响应。为了协调这两者巨大的性能差距，CPU 缓存（通常是多级缓存）就出现了。

根据不断增长的热点数据，这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中L1 和 L2 常用在单核中，L3 则用在多核中。

从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次降低（当然比内存还是好得多）。而它们的命中率，衡量的是 CPU 缓存的复用情况，命中率越高，则表示性能越好。