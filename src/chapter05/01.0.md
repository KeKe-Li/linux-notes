#### linux中的内存分布

在Linux里，其实有不少的内存管理库，比如glibc的`ptmalloc`，FreeBSD的`jemalloc`，Google的`tcmalloc`等等，为何会出现这么多的内存管理库？

其实本质都是在多线程编程下，追求更高内存管理效率：更快的分配内存。

那如何更快的分配内存？


#### 虚拟内存

引入虚拟内存后，让内存的并发访问问题的粒度从多进程级别，降低到多线程级别。

虚拟内存是当代操作系统必备的一项重要功能了，它向进程屏蔽了底层了RAM和磁盘，并向进程提供了远超物理内存大小的内存空间。

访问内存，实际访问的是虚拟内存，虚拟内存通过页表查看，当前要访问的虚拟内存地址，是否已经加载到了物理内存，如果已经在物理内存，则取物理内存数据，如果没有对应的物理内存，则从磁盘加载数据到物理内存，并把物理内存地址和虚拟内存地址更新到页表。

早前在没有虚拟内存的时代，物理内存对所有进程是共享的，多进程同时访问同一个物理内存存在并发访问问题。引入虚拟内存后，每个进程都要各自的虚拟内存，内存的并发访问问题的粒度从多进程级别，可以降低到多线程级别。


#### 堆内存管理
<p align="center">
<img width="300" align="center" src="../images/04.jpg" />
</p>

上图展示了一个进程的虚拟内存划分，代码中使用的内存地址都是虚拟内存地址，而不是实际的物理内存地址。栈和堆只是虚拟内存上2块不同功能的内存区域：

* 栈在高地址，从高地址向低地址增长。

* 堆在低地址，从低地址向高地址增长。

栈和堆相比有这么几个好处：

* 栈的内存管理简单，分配比堆上快。

* 栈的内存不需要回收，而堆需要，无论是主动free，还是被动的垃圾回收，这都需要花费额外的CPU。

* 栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU访问的2块数据可能在不同的页上，CPU访问数据的时间可能就上去了。

#### 栈内存管理

<p align="center">
<img width="300" align="center" src="../images/05.jpg" />
</p>

通常内存管理，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心。这小节看下堆内存管理干的是啥，如上图所示主要是3部分：分配内存块，回收内存块和组织内存块。



#### TCMalloc
